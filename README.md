Tasks-from-Lunev
================

Решения задач, даваемых на 2 курсе ПМФ МФТИ на семинарах Д. Лунева.

## FIFO:

Организовать передачу файла от reader к receiver с помощью fifo.
При этом:
1. При множественном запуске receiver'ов и reader'ов файл не должен повреждаться.
2. При внезапном отключении компьютера от сети и последующем его включении все должно работать сначала.


## MESSAGE:

Изначальный процесс порождает n дочерних процессов.
Дочерние процессы (после завершения цикла порождения в коде) печатают свои номера в порядке, в котором их породили.
Рекомендуемый примитив - очередь сообщений.


## System V Semaphores:

Написать два неродственных процесса, такие, что первый передаёт файл в другой, который печатает его на стандартный вывод; передавать файл надо через разделяемую память, организовать синхронизацию на базе семафоров System V IPC.
При этом:
1. Смерть (например, Ctrl+C или вследствие закрытия терминала) процесса-партнёра должна корректно обрабатываться.
2. Файл не должен портиться.
3. Это всё при множественном запуске как в 1 задаче.

## Signals:
 
Передать файл с помощью сигналов от ребенка к родителю.


## Select:

Аргументы мэйн: имя файла, число детей.
Первый ребёнок читает файл, передает через пайп родителю, родитель передает следующему ... родитель принимает от последнего и печатает;
Родитель одновременно ждёт всех своих детей с помощью селекта, размер буфера в родителе меняется как 1111*n, где n - номер ребёнка.
- Совет: 
использовать массив структур о детях для обеспечения локальности данных для большей производительности кода.


## Parallel evaluation of the integral:

Требуется распараллелить вычисление интеграла от любой удобной вам функции так, чтобы при увеличении количества потоков время уменьшалось линейно. То есть, если на 1 потоке время вычисления составляет 20, то на 2х будет 10, а на 4х -- 5.
Необходимо учитывать hyper-threading и turbo boost. Линейный скейлинг возможен при соответствии реальных ядер процессора количеству тредов.
//в моей реализации идет распараллеливание x^2.

## Parallel evaluation of the integral using network:

Задача: есть несколько вычислителей (у меня workers). Есть клиент (у меня server). Клиент просит посчитать интеграл, раздаёт задачу вычислителям. Те считают и отсылают результат.	
Если кто-то умирает, то воркеры должны об этом узнать, прекратить вычисления, и снова ждать новую задачу.
Клиент соответственно тоже должен об это узнать и выйти.
Также включено условие линейного скейлинга в зависимости от количества вычислителей.
